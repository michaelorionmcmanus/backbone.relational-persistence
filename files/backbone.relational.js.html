<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>backbone.relational.js - backbone.relational-peristence</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="backbone.relational-peristence"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/RelationalPersistence.html">RelationalPersistence</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: backbone.relational.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;* vim: set tabstop=4 softtabstop=4 shiftwidth=4 noexpandtab: *&#x2F;
&#x2F;**
 * Backbone-relational.js 0.8.0
 * (c) 2011-2013 Paul Uithol and contributors (https:&#x2F;&#x2F;github.com&#x2F;PaulUithol&#x2F;Backbone-relational&#x2F;graphs&#x2F;contributors)
 * 
 * Backbone-relational may be freely distributed under the MIT license; see the accompanying LICENSE.txt.
 * For details and documentation: https:&#x2F;&#x2F;github.com&#x2F;PaulUithol&#x2F;Backbone-relational.
 * Depends on Backbone (and thus on Underscore as well): https:&#x2F;&#x2F;github.com&#x2F;documentcloud&#x2F;backbone.
 *&#x2F;
( function( undefined ) {
	&quot;use strict&quot;;

	&#x2F;**
	 * CommonJS shim
	 **&#x2F;
	var _, Backbone, exports;
	if ( typeof window === &#x27;undefined&#x27; ) {
		_ = require( &#x27;underscore&#x27; );
		Backbone = require( &#x27;backbone&#x27; );
		exports = module.exports = Backbone;
	}
	else {
		_ = window._;
		Backbone = window.Backbone;
		exports = window;
	}

	Backbone.Relational = {
		showWarnings: true
	};

	&#x2F;**
	 * Semaphore mixin; can be used as both binary and counting.
	 **&#x2F;
	Backbone.Semaphore = {
		_permitsAvailable: null,
		_permitsUsed: 0,

		acquire: function() {
			if ( this._permitsAvailable &amp;&amp; this._permitsUsed &gt;= this._permitsAvailable ) {
				throw new Error( &#x27;Max permits acquired&#x27; );
			}
			else {
				this._permitsUsed++;
			}
		},

		release: function() {
			if ( this._permitsUsed === 0 ) {
				throw new Error( &#x27;All permits released&#x27; );
			}
			else {
				this._permitsUsed--;
			}
		},

		isLocked: function() {
			return this._permitsUsed &gt; 0;
		},

		setAvailablePermits: function( amount ) {
			if ( this._permitsUsed &gt; amount ) {
				throw new Error( &#x27;Available permits cannot be less than used permits&#x27; );
			}
			this._permitsAvailable = amount;
		}
	};

	&#x2F;**
	 * A BlockingQueue that accumulates items while blocked (via &#x27;block&#x27;),
	 * and processes them when unblocked (via &#x27;unblock&#x27;).
	 * Process can also be called manually (via &#x27;process&#x27;).
	 *&#x2F;
	Backbone.BlockingQueue = function() {
		this._queue = [];
	};
	_.extend( Backbone.BlockingQueue.prototype, Backbone.Semaphore, {
		_queue: null,

		add: function( func ) {
			if ( this.isBlocked() ) {
				this._queue.push( func );
			}
			else {
				func();
			}
		},

		process: function() {
			while ( this._queue &amp;&amp; this._queue.length ) {
				this._queue.shift()();
			}
		},

		block: function() {
			this.acquire();
		},

		unblock: function() {
			this.release();
			if ( !this.isBlocked() ) {
				this.process();
			}
		},

		isBlocked: function() {
			return this.isLocked();
		}
	});
	&#x2F;**
	 * Global event queue. Accumulates external events (&#x27;add:&lt;key&gt;&#x27;, &#x27;remove:&lt;key&gt;&#x27; and &#x27;change:&lt;key&gt;&#x27;)
	 * until the top-level object is fully initialized (see &#x27;Backbone.RelationalModel&#x27;).
	 *&#x2F;
	Backbone.Relational.eventQueue = new Backbone.BlockingQueue();

	&#x2F;**
	 * Backbone.Store keeps track of all created (and destruction of) Backbone.RelationalModel.
	 * Handles lookup for relations.
	 *&#x2F;
	Backbone.Store = function() {
		this._collections = [];
		this._reverseRelations = [];
		this._orphanRelations = [];
		this._subModels = [];
		this._modelScopes = [ exports ];
	};
	_.extend( Backbone.Store.prototype, Backbone.Events, {
		&#x2F;**
		 * Create a new &#x60;Relation&#x60;.
		 * @param {Backbone.RelationalModel} [model]
		 * @param {Object} relation
		 * @param {Object} [options]
		 *&#x2F;
		initializeRelation: function( model, relation, options ) {
			var type = !_.isString( relation.type ) ? relation.type : Backbone[ relation.type ] || this.getObjectByName( relation.type );
			if ( type &amp;&amp; type.prototype instanceof Backbone.Relation ) {
				new type( model, relation, options ); &#x2F;&#x2F; Also pushes the new Relation into &#x60;model._relations&#x60;
			}
			else {
				Backbone.Relational.showWarnings &amp;&amp; typeof console !== &#x27;undefined&#x27; &amp;&amp; console.warn( &#x27;Relation=%o; missing or invalid relation type!&#x27;, relation );
			}
		},

		&#x2F;**
		 * Add a scope for &#x60;getObjectByName&#x60; to look for model types by name.
		 * @param {Object} scope
		 *&#x2F;
		addModelScope: function( scope ) {
			this._modelScopes.push( scope );
		},

		&#x2F;**
		 * Add a set of subModelTypes to the store, that can be used to resolve the &#x27;_superModel&#x27;
		 * for a model later in &#x27;setupSuperModel&#x27;.
		 *
		 * @param {Backbone.RelationalModel} subModelTypes
		 * @param {Backbone.RelationalModel} superModelType
		 *&#x2F;
		addSubModels: function( subModelTypes, superModelType ) {
			this._subModels.push({
				&#x27;superModelType&#x27;: superModelType,
				&#x27;subModels&#x27;: subModelTypes
			});
		},

		&#x2F;**
		 * Check if the given modelType is registered as another model&#x27;s subModel. If so, add it to the super model&#x27;s
		 * &#x27;_subModels&#x27;, and set the modelType&#x27;s &#x27;_superModel&#x27;, &#x27;_subModelTypeName&#x27;, and &#x27;_subModelTypeAttribute&#x27;.
		 *
		 * @param {Backbone.RelationalModel} modelType
		 *&#x2F;
		setupSuperModel: function( modelType ) {
			_.find( this._subModels, function( subModelDef ) {
				return _.find( subModelDef.subModels || [], function( subModelTypeName, typeValue ) {
					var subModelType = this.getObjectByName( subModelTypeName );

					if ( modelType === subModelType ) {
						&#x2F;&#x2F; Set &#x27;modelType&#x27; as a child of the found superModel
						subModelDef.superModelType._subModels[ typeValue ] = modelType;

						&#x2F;&#x2F; Set &#x27;_superModel&#x27;, &#x27;_subModelTypeValue&#x27;, and &#x27;_subModelTypeAttribute&#x27; on &#x27;modelType&#x27;.
						modelType._superModel = subModelDef.superModelType;
						modelType._subModelTypeValue = typeValue;
						modelType._subModelTypeAttribute = subModelDef.superModelType.prototype.subModelTypeAttribute;
						return true;
					}
				}, this );
			}, this );
		},

		&#x2F;**
		 * Add a reverse relation. Is added to the &#x27;relations&#x27; property on model&#x27;s prototype, and to
		 * existing instances of &#x27;model&#x27; in the store as well.
		 * @param {Object} relation
		 * @param {Backbone.RelationalModel} relation.model
		 * @param {String} relation.type
		 * @param {String} relation.key
		 * @param {String|Object} relation.relatedModel
		 *&#x2F;
		addReverseRelation: function( relation ) {
			var exists = _.any( this._reverseRelations, function( rel ) {
				return _.all( relation || [], function( val, key ) {
					return val === rel[ key ];
				});
			});
			
			if ( !exists &amp;&amp; relation.model &amp;&amp; relation.type ) {
				this._reverseRelations.push( relation );
				this._addRelation( relation.model, relation );
				this.retroFitRelation( relation );
			}
		},

		&#x2F;**
		 * Deposit a &#x60;relation&#x60; for which the &#x60;relatedModel&#x60; can&#x27;t be resolved at the moment.
		 *
		 * @param {Object} relation
		 *&#x2F;
		addOrphanRelation: function( relation ) {
			var exists = _.any( this._orphanRelations, function( rel ) {
				return _.all( relation || [], function( val, key ) {
					return val === rel[ key ];
				});
			});

			if ( !exists &amp;&amp; relation.model &amp;&amp; relation.type ) {
				this._orphanRelations.push( relation );
			}
		},

		&#x2F;**
		 * Try to initialize any &#x60;_orphanRelation&#x60;s
		 *&#x2F;
		processOrphanRelations: function() {
			&#x2F;&#x2F; Make sure to operate on a copy since we&#x27;re removing while iterating
			_.each( this._orphanRelations.slice( 0 ), function( rel ) {
				var relatedModel = Backbone.Relational.store.getObjectByName( rel.relatedModel );
				if ( relatedModel ) {
					this.initializeRelation( null, rel );
					this._orphanRelations = _.without( this._orphanRelations, rel );
				}
			}, this );
		},

		&#x2F;**
		 *
		 * @param {Backbone.RelationalModel.constructor} type
		 * @param {Object} relation
		 * @private
		 *&#x2F;
		_addRelation: function( type, relation ) {
			if ( !type.prototype.relations ) {
				type.prototype.relations = [];
			}
			type.prototype.relations.push( relation );

			_.each( type._subModels || [], function( subModel ) {
				this._addRelation( subModel, relation );
			}, this );
		},

		&#x2F;**
		 * Add a &#x27;relation&#x27; to all existing instances of &#x27;relation.model&#x27; in the store
		 * @param {Object} relation
		 *&#x2F;
		retroFitRelation: function( relation ) {
			var coll = this.getCollection( relation.model, false );
			coll &amp;&amp; coll.each( function( model ) {
				if ( !( model instanceof relation.model ) ) {
					return;
				}

				new relation.type( model, relation );
			}, this );
		},

		&#x2F;**
		 * Find the Store&#x27;s collection for a certain type of model.
		 * @param {Backbone.RelationalModel} type
		 * @param {Boolean} [create=true] Should a collection be created if none is found?
		 * @return {Backbone.Collection} A collection if found (or applicable for &#x27;model&#x27;), or null
		 *&#x2F;
		getCollection: function( type, create ) {
			if ( type instanceof Backbone.RelationalModel ) {
				type = type.constructor;
			}
			
			var rootModel = type;
			while ( rootModel._superModel ) {
				rootModel = rootModel._superModel;
			}
			
			var coll = _.findWhere( this._collections, { model: rootModel } );
			
			if ( !coll &amp;&amp; create !== false ) {
				coll = this._createCollection( rootModel );
			}
			
			return coll;
		},

		&#x2F;**
		 * Find a model type on one of the modelScopes by name. Names are split on dots.
		 * @param {String} name
		 * @return {Object}
		 *&#x2F;
		getObjectByName: function( name ) {
			var parts = name.split( &#x27;.&#x27; ),
				type = null;

			_.find( this._modelScopes, function( scope ) {
				type = _.reduce( parts || [], function( memo, val ) {
					return memo ? memo[ val ] : undefined;
				}, scope );

				if ( type &amp;&amp; type !== scope ) {
					return true;
				}
			}, this );

			return type;
		},

		_createCollection: function( type ) {
			var coll;
			
			&#x2F;&#x2F; If &#x27;type&#x27; is an instance, take its constructor
			if ( type instanceof Backbone.RelationalModel ) {
				type = type.constructor;
			}
			
			&#x2F;&#x2F; Type should inherit from Backbone.RelationalModel.
			if ( type.prototype instanceof Backbone.RelationalModel ) {
				coll = new Backbone.Collection();
				coll.model = type;
				
				this._collections.push( coll );
			}
			
			return coll;
		},

		&#x2F;**
		 * Find the attribute that is to be used as the &#x60;id&#x60; on a given object
		 * @param type
		 * @param {String|Number|Object|Backbone.RelationalModel} item
		 * @return {String|Number}
		 *&#x2F;
		resolveIdForItem: function( type, item ) {
			var id = _.isString( item ) || _.isNumber( item ) ? item : null;

			if ( id === null ) {
				if ( item instanceof Backbone.RelationalModel ) {
					id = item.id;
				}
				else if ( _.isObject( item ) ) {
					id = item[ type.prototype.idAttribute ];
				}
			}

			&#x2F;&#x2F; Make all falsy values &#x60;null&#x60; (except for 0, which could be an id.. see &#x27;&#x2F;issues&#x2F;179&#x27;)
			if ( !id &amp;&amp; id !== 0 ) {
				id = null;
			}

			return id;
		},

		&#x2F;**
		 *
		 * @param type
		 * @param {String|Number|Object|Backbone.RelationalModel} item
		 *&#x2F;
		find: function( type, item ) {
			var id = this.resolveIdForItem( type, item );
			var coll = this.getCollection( type );
			
			&#x2F;&#x2F; Because the found object could be of any of the type&#x27;s superModel
			&#x2F;&#x2F; types, only return it if it&#x27;s actually of the type asked for.
			if ( coll ) {
				var obj = coll.get( id );

				if ( obj instanceof type ) {
					return obj;
				}
			}

			return null;
		},

		&#x2F;**
		 * Add a &#x27;model&#x27; to its appropriate collection. Retain the original contents of &#x27;model.collection&#x27;.
		 * @param {Backbone.RelationalModel} model
		 *&#x2F;
		register: function( model ) {
			var coll = this.getCollection( model );

			if ( coll ) {
				if ( coll.get( model ) ) {
					if ( Backbone.Relational.showWarnings &amp;&amp; typeof console !== &#x27;undefined&#x27; ) {
						console.warn( &#x27;Duplicate id! Old RelationalModel=%o, new RelationalModel=%o&#x27;, coll.get( model ), model );
					}
					throw new Error( &quot;Cannot instantiate more than one Backbone.RelationalModel with the same id per type!&quot; );
				}

				var modelColl = model.collection;
				coll.add( model );
				this.listenTo( model, &#x27;destroy&#x27;, this.unregister, this );
				model.collection = modelColl;
			}
		},

		&#x2F;**
		 * Explicitly update a model&#x27;s id in its store collection
		 * @param {Backbone.RelationalModel} model
		*&#x2F;
		update: function( model ) {
			var coll = this.getCollection( model );
			coll._onModelEvent( &#x27;change:&#x27; + model.idAttribute, model, coll );
		},

		&#x2F;**
		 * Remove a &#x27;model&#x27; from the store.
		 * @param {Backbone.RelationalModel} model
		 *&#x2F;
		unregister: function( model ) {
			this.stopListening( model, &#x27;destroy&#x27;, this.unregister );
			var coll = this.getCollection( model );
			coll &amp;&amp; coll.remove( model );
		},

		&#x2F;**
		 * Reset the &#x60;store&#x60; to it&#x27;s original state. The &#x60;reverseRelations&#x60; are kept though, since attempting to
		 * re-initialize these on models would lead to a large amount of warnings.
		 *&#x2F;
		reset: function() {
			this.stopListening();
			this._collections = [];
			this._subModels = [];
			this._modelScopes = [ exports ];
		}
	});
	Backbone.Relational.store = new Backbone.Store();

	&#x2F;**
	 * The main Relation class, from which &#x27;HasOne&#x27; and &#x27;HasMany&#x27; inherit. Internally, &#x27;relational:&lt;key&gt;&#x27; events
	 * are used to regulate addition and removal of models from relations.
	 *
	 * @param {Backbone.RelationalModel} [instance] Model that this relation is created for. If no model is supplied,
	 *      Relation just tries to instantiate it&#x27;s &#x60;reverseRelation&#x60; if specified, and bails out after that.
	 * @param {Object} options
	 * @param {string} options.key
	 * @param {Backbone.RelationalModel.constructor} options.relatedModel
	 * @param {Boolean|String} [options.includeInJSON=true] Serialize the given attribute for related model(s)&#x27; in toJSON, or just their ids.
	 * @param {Boolean} [options.createModels=true] Create objects from the contents of keys if the object is not found in Backbone.store.
	 * @param {Object} [options.reverseRelation] Specify a bi-directional relation. If provided, Relation will reciprocate
	 *    the relation to the &#x27;relatedModel&#x27;. Required and optional properties match &#x27;options&#x27;, except that it also needs
	 *    {Backbone.Relation|String} type (&#x27;HasOne&#x27; or &#x27;HasMany&#x27;).
	 * @param {Object} opts
	 *&#x2F;
	Backbone.Relation = function( instance, options, opts ) {
		this.instance = instance;
		&#x2F;&#x2F; Make sure &#x27;options&#x27; is sane, and fill with defaults from subclasses and this object&#x27;s prototype
		options = _.isObject( options ) ? options : {};
		this.reverseRelation = _.defaults( options.reverseRelation || {}, this.options.reverseRelation );
		this.options = _.defaults( options, this.options, Backbone.Relation.prototype.options );

		this.reverseRelation.type = !_.isString( this.reverseRelation.type ) ? this.reverseRelation.type :
			Backbone[ this.reverseRelation.type ] || Backbone.Relational.store.getObjectByName( this.reverseRelation.type );

		this.key = this.options.key;
		this.keySource = this.options.keySource || this.key;
		this.keyDestination = this.options.keyDestination || this.keySource || this.key;

		this.model = this.options.model || this.instance.constructor;
		this.relatedModel = this.options.relatedModel;
		if ( _.isString( this.relatedModel ) ) {
			this.relatedModel = Backbone.Relational.store.getObjectByName( this.relatedModel );
		}

		if ( !this.checkPreconditions() ) {
			return;
		}

		&#x2F;&#x2F; Add the reverse relation on &#x27;relatedModel&#x27; to the store&#x27;s reverseRelations
		if ( !this.options.isAutoRelation &amp;&amp; this.reverseRelation.type &amp;&amp; this.reverseRelation.key ) {
			Backbone.Relational.store.addReverseRelation( _.defaults( {
					isAutoRelation: true,
					model: this.relatedModel,
					relatedModel: this.model,
					reverseRelation: this.options &#x2F;&#x2F; current relation is the &#x27;reverseRelation&#x27; for its own reverseRelation
				},
				this.reverseRelation &#x2F;&#x2F; Take further properties from this.reverseRelation (type, key, etc.)
			) );
		}

		if ( instance ) {
			var contentKey = this.keySource;
			if ( contentKey !== this.key &amp;&amp; typeof this.instance.get( this.key ) === &#x27;object&#x27; ) {
				contentKey = this.key;
			}

			this.setKeyContents( this.instance.get( contentKey ) );
			this.relatedCollection = Backbone.Relational.store.getCollection( this.relatedModel );

			&#x2F;&#x2F; Explicitly clear &#x27;keySource&#x27;, to prevent a leaky abstraction if &#x27;keySource&#x27; differs from &#x27;key&#x27;.
			if ( this.keySource !== this.key ) {
				this.instance.unset( this.keySource, { silent: true } );
			}

			&#x2F;&#x2F; Add this Relation to instance._relations
			this.instance._relations[ this.key ] = this;

			this.initialize( opts );

			if ( this.options.autoFetch ) {
				this.instance.fetchRelated( this.key, _.isObject( this.options.autoFetch ) ? this.options.autoFetch : {} );
			}

			&#x2F;&#x2F; When &#x27;relatedModel&#x27; are created or destroyed, check if it affects this relation.
			this.listenTo( this.instance, &#x27;destroy&#x27;, this.destroy )
				.listenTo( this.relatedCollection, &#x27;relational:add&#x27;, this.tryAddRelated )
				.listenTo( this.relatedCollection, &#x27;relational:remove&#x27;, this.removeRelated )
		}
	};
	&#x2F;&#x2F; Fix inheritance :\
	Backbone.Relation.extend = Backbone.Model.extend;
	&#x2F;&#x2F; Set up all inheritable **Backbone.Relation** properties and methods.
	_.extend( Backbone.Relation.prototype, Backbone.Events, Backbone.Semaphore, {
		options: {
			createModels: true,
			includeInJSON: true,
			isAutoRelation: false,
			autoFetch: false,
			parse: false
		},

		instance: null,
		key: null,
		keyContents: null,
		relatedModel: null,
		relatedCollection: null,
		reverseRelation: null,
		related: null,

		&#x2F;**
		 * Check several pre-conditions.
		 * @return {Boolean} True if pre-conditions are satisfied, false if they&#x27;re not.
		 *&#x2F;
		checkPreconditions: function() {
			var i = this.instance,
				k = this.key,
				m = this.model,
				rm = this.relatedModel,
				warn = Backbone.Relational.showWarnings &amp;&amp; typeof console !== &#x27;undefined&#x27;;

			if ( !m || !k || !rm ) {
				warn &amp;&amp; console.warn( &#x27;Relation=%o: missing model, key or relatedModel (%o, %o, %o).&#x27;, this, m, k, rm );
				return false;
			}
			&#x2F;&#x2F; Check if the type in &#x27;model&#x27; inherits from Backbone.RelationalModel
			if ( !( m.prototype instanceof Backbone.RelationalModel ) ) {
				warn &amp;&amp; console.warn( &#x27;Relation=%o: model does not inherit from Backbone.RelationalModel (%o).&#x27;, this, i );
				return false;
			}
			&#x2F;&#x2F; Check if the type in &#x27;relatedModel&#x27; inherits from Backbone.RelationalModel
			if ( !( rm.prototype instanceof Backbone.RelationalModel ) ) {
				warn &amp;&amp; console.warn( &#x27;Relation=%o: relatedModel does not inherit from Backbone.RelationalModel (%o).&#x27;, this, rm );
				return false;
			}
			&#x2F;&#x2F; Check if this is not a HasMany, and the reverse relation is HasMany as well
			if ( this instanceof Backbone.HasMany &amp;&amp; this.reverseRelation.type === Backbone.HasMany ) {
				warn &amp;&amp; console.warn( &#x27;Relation=%o: relation is a HasMany, and the reverseRelation is HasMany as well.&#x27;, this );
				return false;
			}
			&#x2F;&#x2F; Check if we&#x27;re not attempting to create a relationship on a &#x60;key&#x60; that&#x27;s already used.
			if ( i &amp;&amp; _.keys( i._relations ).length ) {
				var existing = _.find( i._relations, function( rel ) {
					return rel.key === k;
				}, this );

				if ( existing ) {
					warn &amp;&amp; console.warn( &#x27;Cannot create relation=%o on %o for model=%o: already taken by relation=%o.&#x27;,
						this, k, i, existing );
					return false;
				}
			}

			return true;
		},

		&#x2F;**
		 * Set the related model(s) for this relation
		 * @param {Backbone.Model|Backbone.Collection} related
		 *&#x2F;
		setRelated: function( related ) {
			this.related = related;

			this.instance.acquire();
			this.instance.attributes[ this.key ] = related;
			this.instance.release();
		},

		&#x2F;**
		 * Determine if a relation (on a different RelationalModel) is the reverse
		 * relation of the current one.
		 * @param {Backbone.Relation} relation
		 * @return {Boolean}
		 *&#x2F;
		_isReverseRelation: function( relation ) {
			return relation.instance instanceof this.relatedModel &amp;&amp; this.reverseRelation.key === relation.key &amp;&amp;
				this.key === relation.reverseRelation.key;
		},

		&#x2F;**
		 * Get the reverse relations (pointing back to &#x27;this.key&#x27; on &#x27;this.instance&#x27;) for the currently related model(s).
		 * @param {Backbone.RelationalModel} [model] Get the reverse relations for a specific model.
		 *    If not specified, &#x27;this.related&#x27; is used.
		 * @return {Backbone.Relation[]}
		 *&#x2F;
		getReverseRelations: function( model ) {
			var reverseRelations = [];
			&#x2F;&#x2F; Iterate over &#x27;model&#x27;, &#x27;this.related.models&#x27; (if this.related is a Backbone.Collection), or wrap &#x27;this.related&#x27; in an array.
			var models = !_.isUndefined( model ) ? [ model ] : this.related &amp;&amp; ( this.related.models || [ this.related ] );
			_.each( models || [], function( related ) {
				_.each( related.getRelations() || [], function( relation ) {
						if ( this._isReverseRelation( relation ) ) {
							reverseRelations.push( relation );
						}
					}, this );
			}, this );
			
			return reverseRelations;
		},

		&#x2F;**
		 * When &#x60;this.instance&#x60; is destroyed, cleanup our relations.
		 * Get reverse relation, call removeRelated on each.
		 *&#x2F;
		destroy: function() {
			this.stopListening();

			if ( this instanceof Backbone.HasOne ) {
				this.setRelated( null );
			}
			else if ( this instanceof Backbone.HasMany ) {
				this.setRelated( this._prepareCollection() );
			}
			
			_.each( this.getReverseRelations(), function( relation ) {
				relation.removeRelated( this.instance );
			}, this );
		}
	});

	Backbone.HasOne = Backbone.Relation.extend({
		options: {
			reverseRelation: { type: &#x27;HasMany&#x27; }
		},

		initialize: function( opts ) {
			this.listenTo( this.instance, &#x27;relational:change:&#x27; + this.key, this.onChange );

			var related = this.findRelated( opts );
			this.setRelated( related );

			&#x2F;&#x2F; Notify new &#x27;related&#x27; object of the new relation.
			_.each( this.getReverseRelations(), function( relation ) {
				relation.addRelated( this.instance, opts );
			}, this );
		},

		&#x2F;**
		 * Find related Models.
		 * @param {Object} [options]
		 * @return {Backbone.Model}
		 *&#x2F;
		findRelated: function( options ) {
			var related = null;

			options = _.defaults( { parse: this.options.parse }, options );

			if ( this.keyContents instanceof this.relatedModel ) {
				related = this.keyContents;
			}
			else if ( this.keyContents || this.keyContents === 0 ) { &#x2F;&#x2F; since 0 can be a valid &#x60;id&#x60; as well
				var opts = _.defaults( { create: this.options.createModels }, options );
				related = this.relatedModel.findOrCreate( this.keyContents, opts );
			}

			return related;
		},

		&#x2F;**
		 * Normalize and reduce &#x60;keyContents&#x60; to an &#x60;id&#x60;, for easier comparison
		 * @param {String|Number|Backbone.Model} keyContents
		 *&#x2F;
		setKeyContents: function( keyContents ) {
			this.keyContents = keyContents;
			this.keyId = Backbone.Relational.store.resolveIdForItem( this.relatedModel, this.keyContents );
		},

		&#x2F;**
		 * Event handler for &#x60;change:&lt;key&gt;&#x60;.
		 * If the key is changed, notify old &amp; new reverse relations and initialize the new relation.
		 *&#x2F;
		onChange: function( model, attr, options ) {
			&#x2F;&#x2F; Don&#x27;t accept recursive calls to onChange (like onChange-&gt;findRelated-&gt;findOrCreate-&gt;initializeRelations-&gt;addRelated-&gt;onChange)
			if ( this.isLocked() ) {
				return;
			}
			this.acquire();
			options = options ? _.clone( options ) : {};
			
			&#x2F;&#x2F; &#x27;options.__related&#x27; is set by &#x27;addRelated&#x27;&#x2F;&#x27;removeRelated&#x27;. If it is set, the change
			&#x2F;&#x2F; is the result of a call from a relation. If it&#x27;s not, the change is the result of 
			&#x2F;&#x2F; a &#x27;set&#x27; call on this.instance.
			var changed = _.isUndefined( options.__related ),
				oldRelated = changed ? this.related : options.__related;
			
			if ( changed ) {
				this.setKeyContents( attr );
				var related = this.findRelated( options );
				this.setRelated( related );
			}
			
			&#x2F;&#x2F; Notify old &#x27;related&#x27; object of the terminated relation
			if ( oldRelated &amp;&amp; this.related !== oldRelated ) {
				_.each( this.getReverseRelations( oldRelated ), function( relation ) {
					relation.removeRelated( this.instance, null, options );
				}, this );
			}

			&#x2F;&#x2F; Notify new &#x27;related&#x27; object of the new relation. Note we do re-apply even if this.related is oldRelated;
			&#x2F;&#x2F; that can be necessary for bi-directional relations if &#x27;this.instance&#x27; was created after &#x27;this.related&#x27;.
			&#x2F;&#x2F; In that case, &#x27;this.instance&#x27; will already know &#x27;this.related&#x27;, but the reverse might not exist yet.
			_.each( this.getReverseRelations(), function( relation ) {
				relation.addRelated( this.instance, options );
			}, this );
			
			&#x2F;&#x2F; Fire the &#x27;change:&lt;key&gt;&#x27; event if &#x27;related&#x27; was updated
			if ( !options.silent &amp;&amp; this.related !== oldRelated ) {
				var dit = this;
				this.changed = true;
				Backbone.Relational.eventQueue.add( function() {
					dit.instance.trigger( &#x27;change:&#x27; + dit.key, dit.instance, dit.related, options, true );
					dit.changed = false;
				});
			}
			this.release();
		},

		&#x2F;**
		 * If a new &#x27;this.relatedModel&#x27; appears in the &#x27;store&#x27;, try to match it to the last set &#x27;keyContents&#x27;
		 *&#x2F;
		tryAddRelated: function( model, coll, options ) {
			if ( ( this.keyId || this.keyId === 0 ) &amp;&amp; model.id === this.keyId ) { &#x2F;&#x2F; since 0 can be a valid &#x60;id&#x60; as well
				this.addRelated( model, options );
				this.keyId = null;
			}
		},

		addRelated: function( model, options ) {
			&#x2F;&#x2F; Allow &#x27;model&#x27; to set up its relations before proceeding.
			&#x2F;&#x2F; (which can result in a call to &#x27;addRelated&#x27; from a relation of &#x27;model&#x27;)
			var dit = this;
			model.queue( function() {
				if ( model !== dit.related ) {
					var oldRelated = dit.related || null;
					dit.setRelated( model );
					dit.onChange( dit.instance, model, _.defaults( { __related: oldRelated }, options ) );
				}
			});
		},

		removeRelated: function( model, coll, options ) {
			if ( !this.related ) {
				return;
			}
			
			if ( model === this.related ) {
				var oldRelated = this.related || null;
				this.setRelated( null );
				this.onChange( this.instance, model, _.defaults( { __related: oldRelated }, options ) );
			}
		}
	});

	Backbone.HasMany = Backbone.Relation.extend({
		collectionType: null,

		options: {
			reverseRelation: { type: &#x27;HasOne&#x27; },
			collectionType: Backbone.Collection,
			collectionKey: true,
			collectionOptions: {}
		},

		initialize: function( opts ) {
			this.listenTo( this.instance, &#x27;relational:change:&#x27; + this.key, this.onChange );
			
			&#x2F;&#x2F; Handle a custom &#x27;collectionType&#x27;
			this.collectionType = this.options.collectionType;
			if ( _.isString( this.collectionType ) ) {
				this.collectionType = Backbone.Relational.store.getObjectByName( this.collectionType );
			}
			if ( !this.collectionType.prototype instanceof Backbone.Collection ){
				throw new Error( &#x27;&#x60;collectionType&#x60; must inherit from Backbone.Collection&#x27; );
			}

			var related = this.findRelated( opts );
			this.setRelated( related );
		},

		&#x2F;**
		 * Bind events and setup collectionKeys for a collection that is to be used as the backing store for a HasMany.
		 * If no &#x27;collection&#x27; is supplied, a new collection will be created of the specified &#x27;collectionType&#x27; option.
		 * @param {Backbone.Collection} [collection]
		 * @return {Backbone.Collection}
		 *&#x2F;
		_prepareCollection: function( collection ) {
			if ( this.related ) {
				this.stopListening( this.related );
			}

			if ( !collection || !( collection instanceof Backbone.Collection ) ) {
				var options = _.isFunction( this.options.collectionOptions ) ?
					this.options.collectionOptions( this.instance ) : this.options.collectionOptions;

				collection = new this.collectionType( null, options );
			}

			collection.model = this.relatedModel;
			
			if ( this.options.collectionKey ) {
				var key = this.options.collectionKey === true ? this.options.reverseRelation.key : this.options.collectionKey;
				
				if ( collection[ key ] &amp;&amp; collection[ key ] !== this.instance ) {
					if ( Backbone.Relational.showWarnings &amp;&amp; typeof console !== &#x27;undefined&#x27; ) {
						console.warn( &#x27;Relation=%o; collectionKey=%s already exists on collection=%o&#x27;, this, key, this.options.collectionKey );
					}
				}
				else if ( key ) {
					collection[ key ] = this.instance;
				}
			}

			this.listenTo( collection, &#x27;relational:add&#x27;, this.handleAddition )
				.listenTo( collection, &#x27;relational:remove&#x27;, this.handleRemoval )
				.listenTo( collection, &#x27;relational:reset&#x27;, this.handleReset );
			
			return collection;
		},

		&#x2F;**
		 * Find related Models.
		 * @param {Object} [options]
		 * @return {Backbone.Collection}
		 *&#x2F;
		findRelated: function( options ) {
			var related = null;

			options = _.defaults( { parse: this.options.parse }, options );

			&#x2F;&#x2F; Replace &#x27;this.related&#x27; by &#x27;this.keyContents&#x27; if it is a Backbone.Collection
			if ( this.keyContents instanceof Backbone.Collection ) {
				this._prepareCollection( this.keyContents );
				related = this.keyContents;
			}
			&#x2F;&#x2F; Otherwise, &#x27;this.keyContents&#x27; should be an array of related object ids.
			&#x2F;&#x2F; Re-use the current &#x27;this.related&#x27; if it is a Backbone.Collection; otherwise, create a new collection.
			else {
				var toAdd = [];

				_.each( this.keyContents, function( attributes ) {
					if ( attributes instanceof this.relatedModel ) {
						var model = attributes;
					}
					else {
						&#x2F;&#x2F; If &#x60;merge&#x60; is true, update models here, instead of during update.
						model = this.relatedModel.findOrCreate( attributes, _.extend( { merge: true }, options, { create: this.options.createModels } ) );
					}

					model &amp;&amp; toAdd.push( model );
				}, this );

				if ( this.related instanceof Backbone.Collection ) {
					related = this.related;
				}
				else {
					related = this._prepareCollection();
				}

				related.update( toAdd, _.defaults( { merge: false, parse: false }, options ) );
			}

			return related;
		},

		&#x2F;**
		 * Normalize and reduce &#x60;keyContents&#x60; to a list of &#x60;ids&#x60;, for easier comparison
		 * @param {String|Number|String[]|Number[]|Backbone.Collection} keyContents
		 *&#x2F;
		setKeyContents: function( keyContents ) {
			this.keyContents = keyContents instanceof Backbone.Collection ? keyContents : null;
			this.keyIds = [];

			if ( !this.keyContents &amp;&amp; ( keyContents || keyContents === 0 ) ) { &#x2F;&#x2F; since 0 can be a valid &#x60;id&#x60; as well
				&#x2F;&#x2F; Handle cases the an API&#x2F;user supplies just an Object&#x2F;id instead of an Array
				this.keyContents = _.isArray( keyContents ) ? keyContents : [ keyContents ];

				_.each( this.keyContents, function( item ) {
					var itemId = Backbone.Relational.store.resolveIdForItem( this.relatedModel, item );
					if ( itemId || itemId === 0 ) {
						this.keyIds.push( itemId );
					}
				}, this );
			}
		},

		&#x2F;**
		 * Event handler for &#x60;change:&lt;key&gt;&#x60;.
		 * If the contents of the key are changed, notify old &amp; new reverse relations and initialize the new relation.
		 *&#x2F;
		onChange: function( model, attr, options ) {
			options = options ? _.clone( options ) : {};
			this.setKeyContents( attr );
			this.changed = false;

			var related = this.findRelated( options );
			this.setRelated( related );

			if ( !options.silent ) {
				var dit = this;
				Backbone.Relational.eventQueue.add( function() {
					&#x2F;&#x2F; The &#x60;changed&#x60; flag can be set in &#x60;handleAddition&#x60; or &#x60;handleRemoval&#x60;
					if ( dit.changed ) {
						dit.instance.trigger( &#x27;change:&#x27; + dit.key, dit.instance, dit.related, options, true );
						dit.changed = false;
					}
				});
			}
		},

		&#x2F;**
		 * When a model is added to a &#x27;HasMany&#x27;, trigger &#x27;add&#x27; on &#x27;this.instance&#x27; and notify reverse relations.
		 * (should be &#x27;HasOne&#x27;, must set &#x27;this.instance&#x27; as their related).
		*&#x2F;
		handleAddition: function( model, coll, options ) {
			&#x2F;&#x2F;console.debug(&#x27;handleAddition called; args=%o&#x27;, arguments);
			options = options ? _.clone( options ) : {};
			this.changed = true;
			
			_.each( this.getReverseRelations( model ), function( relation ) {
				relation.addRelated( this.instance, options );
			}, this );

			&#x2F;&#x2F; Only trigger &#x27;add&#x27; once the newly added model is initialized (so, has its relations set up)
			var dit = this;
			!options.silent &amp;&amp; Backbone.Relational.eventQueue.add( function() {
				dit.instance.trigger( &#x27;add:&#x27; + dit.key, model, dit.related, options );
			});
		},

		&#x2F;**
		 * When a model is removed from a &#x27;HasMany&#x27;, trigger &#x27;remove&#x27; on &#x27;this.instance&#x27; and notify reverse relations.
		 * (should be &#x27;HasOne&#x27;, which should be nullified)
		 *&#x2F;
		handleRemoval: function( model, coll, options ) {
			&#x2F;&#x2F;console.debug(&#x27;handleRemoval called; args=%o&#x27;, arguments);
			options = options ? _.clone( options ) : {};
			this.changed = true;
			
			_.each( this.getReverseRelations( model ), function( relation ) {
				relation.removeRelated( this.instance, null, options );
			}, this );
			
			var dit = this;
			!options.silent &amp;&amp; Backbone.Relational.eventQueue.add( function() {
				 dit.instance.trigger( &#x27;remove:&#x27; + dit.key, model, dit.related, options );
			});
		},

		handleReset: function( coll, options ) {
			var dit = this;
			options = options ? _.clone( options ) : {};
			!options.silent &amp;&amp; Backbone.Relational.eventQueue.add( function() {
				dit.instance.trigger( &#x27;reset:&#x27; + dit.key, dit.related, options );
			});
		},

		tryAddRelated: function( model, coll, options ) {
			var item = _.contains( this.keyIds, model.id );

			if ( item ) {
				this.addRelated( model, options );
				this.keyIds = _.without( this.keyIds, model.id );
			}
		},

		addRelated: function( model, options ) {
			&#x2F;&#x2F; Allow &#x27;model&#x27; to set up its relations before proceeding.
			&#x2F;&#x2F; (which can result in a call to &#x27;addRelated&#x27; from a relation of &#x27;model&#x27;)
			var dit = this;
			model.queue( function() {
				if ( dit.related &amp;&amp; !dit.related.get( model ) ) {
					dit.related.add( model, options );
				}
			});
		},

		removeRelated: function( model, coll, options ) {
			if ( this.related.get( model ) ) {
				this.related.remove( model, options );
			}
		}
	});

	&#x2F;**
	 * A type of Backbone.Model that also maintains relations to other models and collections.
	 * New events when compared to the original:
	 *  - &#x27;add:&lt;key&gt;&#x27; (model, related collection, options)
	 *  - &#x27;remove:&lt;key&gt;&#x27; (model, related collection, options)
	 *  - &#x27;change:&lt;key&gt;&#x27; (model, related model or collection, options)
	 *&#x2F;
	Backbone.RelationalModel = Backbone.Model.extend({
		relations: null, &#x2F;&#x2F; Relation descriptions on the prototype
		_relations: null, &#x2F;&#x2F; Relation instances
		_isInitialized: false,
		_deferProcessing: false,
		_queue: null,

		subModelTypeAttribute: &#x27;type&#x27;,
		subModelTypes: null,

		constructor: function( attributes, options ) {
			&#x2F;&#x2F; Nasty hack, for cases like &#x27;model.get( &lt;HasMany key&gt; ).add( item )&#x27;.
			&#x2F;&#x2F; Defer &#x27;processQueue&#x27;, so that when &#x27;Relation.createModels&#x27; is used we trigger &#x27;HasMany&#x27;
			&#x2F;&#x2F; collection events only after the model is really fully set up.
			&#x2F;&#x2F; Example: &quot;p.get(&#x27;jobs&#x27;).add( { company: c, person: p } )&quot;.
			if ( options &amp;&amp; options.collection ) {
				var dit = this,
					collection = this.collection =  options.collection;

				&#x2F;&#x2F; Prevent this option from cascading down to related models; they shouldn&#x27;t go into this &#x60;if&#x60; clause.
				delete options.collection;

				this._deferProcessing = true;

				var processQueue = function( model ) {
					if ( model === dit ) {
						dit._deferProcessing = false;
						dit.processQueue();
						collection.off( &#x27;relational:add&#x27;, processQueue );
					}
				};
				collection.on( &#x27;relational:add&#x27;, processQueue );

				&#x2F;&#x2F; So we do process the queue eventually, regardless of whether this model actually gets added to &#x27;options.collection&#x27;.
				_.defer( function() {
					processQueue( dit );
				});
			}

			Backbone.Relational.store.processOrphanRelations();
			
			this._queue = new Backbone.BlockingQueue();
			this._queue.block();
			Backbone.Relational.eventQueue.block();

			try {
				Backbone.Model.apply( this, arguments );
			}
			finally {
				&#x2F;&#x2F; Try to run the global queue holding external events
				Backbone.Relational.eventQueue.unblock();
			}
		},

		&#x2F;**
		 * Override &#x27;trigger&#x27; to queue &#x27;change&#x27; and &#x27;change:*&#x27; events
		 *&#x2F;
		trigger: function( eventName ) {
			if ( eventName.length &gt; 5 &amp;&amp; eventName.indexOf( &#x27;change&#x27; ) === 0 ) {
				var dit = this,
					args = arguments;

				Backbone.Relational.eventQueue.add( function() {
					if ( !dit._isInitialized ) {
						return;
					}

					&#x2F;&#x2F; Determine if the &#x60;change&#x60; event is still valid, now that all relations are populated
					var changed = true;
					if ( eventName === &#x27;change&#x27; ) {
						changed = dit.hasChanged();
					}
					else {
						var attr = eventName.slice( 7 ),
							rel = dit.getRelation( attr );

						if ( rel ) {
							&#x2F;&#x2F; If &#x60;attr&#x60; is a relation, &#x60;change:attr&#x60; get triggered from &#x60;Relation.onChange&#x60;.
							&#x2F;&#x2F; These take precedence over &#x60;change:attr&#x60; events triggered by &#x60;Model.set&#x60;.
							&#x2F;&#x2F; The relation set a fourth attribute to &#x60;true&#x60;. If this attribute is present,
							&#x2F;&#x2F; continue triggering this event; otherwise, it&#x27;s from &#x60;Model.set&#x60; and should be stopped.
							changed = ( args[ 4 ] === true );

							&#x2F;&#x2F; If this event was triggered by a relation, set the right value in &#x60;this.changed&#x60;
							&#x2F;&#x2F; (a Collection or Model instead of raw data).
							if ( changed ) {
								dit.changed[ attr ] = args[ 2 ];
							}
							&#x2F;&#x2F; Otherwise, this event is from &#x60;Model.set&#x60;. If the relation doesn&#x27;t report a change,
							&#x2F;&#x2F; remove attr from &#x60;dit.changed&#x60; so &#x60;hasChanged&#x60; doesn&#x27;t take it into account.
							else if ( !rel.changed ) {
								delete dit.changed[ attr ];
							}
						}
					}

					changed &amp;&amp; Backbone.Model.prototype.trigger.apply( dit, args );
				});
			}
			else {
				Backbone.Model.prototype.trigger.apply( this, arguments );
			}
			
			return this;
		},

		&#x2F;**
		 * Initialize Relations present in this.relations; determine the type (HasOne&#x2F;HasMany), then creates a new instance.
		 * Invoked in the first call so &#x27;set&#x27; (which is made from the Backbone.Model constructor).
		 *&#x2F;
		initializeRelations: function( options ) {
			this.acquire(); &#x2F;&#x2F; Setting up relations often also involve calls to &#x27;set&#x27;, and we only want to enter this function once
			this._relations = {};
			
			_.each( this.relations || [], function( rel ) {
				Backbone.Relational.store.initializeRelation( this, rel, options );
			}, this );
			
			this._isInitialized = true;
			this.release();
			this.processQueue();
		},

		&#x2F;**
		 * When new values are set, notify this model&#x27;s relations (also if options.silent is set).
		 * (Relation.setRelated locks this model before calling &#x27;set&#x27; on it to prevent loops)
		 *&#x2F;
		updateRelations: function( options ) {
			if ( this._isInitialized &amp;&amp; !this.isLocked() ) {
				_.each( this._relations, function( rel ) {
					&#x2F;&#x2F; Update from data in &#x60;rel.keySource&#x60; if set, or &#x60;rel.key&#x60; otherwise
					var val = this.attributes[ rel.keySource ] || this.attributes[ rel.key ];
					if ( rel.related !== val ) {
						this.trigger( &#x27;relational:change:&#x27; + rel.key, this, val, options || {} );
					}
				}, this );
			}
		},

		&#x2F;**
		 * Either add to the queue (if we&#x27;re not initialized yet), or execute right away.
		 *&#x2F;
		queue: function( func ) {
			this._queue.add( func );
		},

		&#x2F;**
		 * Process _queue
		 *&#x2F;
		processQueue: function() {
			if ( this._isInitialized &amp;&amp; !this._deferProcessing &amp;&amp; this._queue.isBlocked() ) {
				this._queue.unblock();
			}
		},

		&#x2F;**
		 * Get a specific relation.
		 * @param key {string} The relation key to look for.
		 * @return {Backbone.Relation} An instance of &#x27;Backbone.Relation&#x27;, if a relation was found for &#x27;key&#x27;, or null.
		 *&#x2F;
		getRelation: function( key ) {
			return this._relations[ key ];
		},

		&#x2F;**
		 * Get all of the created relations.
		 * @return {Backbone.Relation[]}
		 *&#x2F;
		getRelations: function() {
			return _.values( this._relations );
		},

		&#x2F;**
		 * Retrieve related objects.
		 * @param key {string} The relation key to fetch models for.
		 * @param [options] {Object} Options for &#x27;Backbone.Model.fetch&#x27; and &#x27;Backbone.sync&#x27;.
		 * @param [refresh=false] {boolean} Fetch existing models from the server as well (in order to update them).
		 * @return {jQuery.when[]} An array of request objects
		 *&#x2F;
		fetchRelated: function( key, options, refresh ) {
			&#x2F;&#x2F; Set default &#x60;options&#x60; for fetch
			options = _.extend( { update: true, remove: false }, options );

			var setUrl,
				requests = [],
				rel = this.getRelation( key ),
				keys = rel &amp;&amp; ( rel.keyIds || [ rel.keyId ] ),
				toFetch = keys &amp;&amp; _.select( keys || [], function( id ) {
					return ( id || id === 0 ) &amp;&amp; ( refresh || !Backbone.Relational.store.find( rel.relatedModel, id ) );
				}, this );
			
			if ( toFetch &amp;&amp; toFetch.length ) {
				&#x2F;&#x2F; Find (or create) a model for each one that is to be fetched
				var created = [],
					models = _.map( toFetch, function( id ) {
						var model = Backbone.Relational.store.find( rel.relatedModel, id );
						
						if ( !model ) {
							var attrs = {};
							attrs[ rel.relatedModel.prototype.idAttribute ] = id;
							model = rel.relatedModel.findOrCreate( attrs, options );
							created.push( model );
						}

						return model;
					}, this );
				
				&#x2F;&#x2F; Try if the &#x27;collection&#x27; can provide a url to fetch a set of models in one request.
				if ( rel.related instanceof Backbone.Collection &amp;&amp; _.isFunction( rel.related.url ) ) {
					setUrl = rel.related.url( models );
				}
				
				&#x2F;&#x2F; An assumption is that when &#x27;Backbone.Collection.url&#x27; is a function, it can handle building of set urls.
				&#x2F;&#x2F; To make sure it can, test if the url we got by supplying a list of models to fetch is different from
				&#x2F;&#x2F; the one supplied for the default fetch action (without args to &#x27;url&#x27;).
				if ( setUrl &amp;&amp; setUrl !== rel.related.url() ) {
					var opts = _.defaults(
						{
							error: function() {
								var args = arguments;
								_.each( created, function( model ) {
									model.trigger( &#x27;destroy&#x27;, model, model.collection, options );
									options.error &amp;&amp; options.error.apply( model, args );
								});
							},
							url: setUrl
						},
						options
					);

					requests = [ rel.related.fetch( opts ) ];
				}
				else {
					requests = _.map( models, function( model ) {
						var opts = _.defaults(
							{
								error: function() {
									if ( _.contains( created, model ) ) {
										model.trigger( &#x27;destroy&#x27;, model, model.collection, options );
										options.error &amp;&amp; options.error.apply( model, arguments );
									}
								}
							},
							options
						);
						return model.fetch( opts );
					}, this );
				}
			}
			
			return requests;
		},

		get: function( attr ) {
			var originalResult = Backbone.Model.prototype.get.call( this, attr );

			&#x2F;&#x2F; Use &#x60;originalResult&#x60; get if dotNotation not enabled or not required because no dot is in &#x60;attr&#x60;
			if ( !this.dotNotation || attr.indexOf( &#x27;.&#x27; ) === -1 ) {
				return originalResult;
			}

			&#x2F;&#x2F; Go through all splits and return the final result
			var splits = attr.split( &#x27;.&#x27; );
			var result = _.reduce(splits, function( model, split ) {
				if ( !( model instanceof Backbone.Model ) ) {
					throw new Error( &#x27;Attribute must be an instanceof Backbone.Model. Is: &#x27; + model + &#x27;, currentSplit: &#x27; + split );
				}

				return Backbone.Model.prototype.get.call( model, split );
			}, this );

			if ( originalResult !== undefined &amp;&amp; result !== undefined ) {
				throw new Error( &quot;Ambiguous result for &#x27;&quot; + attr + &quot;&#x27;. direct result: &quot; + originalResult + &quot;, dotNotation: &quot; + result );
			}

			return originalResult || result;
		},

		set: function( key, value, options ) {
			Backbone.Relational.eventQueue.block();
			
			&#x2F;&#x2F; Duplicate backbone&#x27;s behavior to allow separate key&#x2F;value parameters, instead of a single &#x27;attributes&#x27; object
			var attributes;
			if ( _.isObject( key ) || key == null ) {
				attributes = key;
				options = value;
			}
			else {
				attributes = {};
				attributes[ key ] = value;
			}
			
			var result = Backbone.Model.prototype.set.apply( this, arguments );
			
			&#x2F;&#x2F; Ideal place to set up relations :)
			try {
				if ( !this._isInitialized &amp;&amp; !this.isLocked() ) {
					this.constructor.initializeModelHierarchy();

					Backbone.Relational.store.register( this );

					this.initializeRelations( options );
				}
				&#x2F;&#x2F; Update the &#x27;idAttribute&#x27; in Backbone.store if; we don&#x27;t want it to miss an &#x27;id&#x27; update due to {silent:true}
				else if ( attributes &amp;&amp; this.idAttribute in attributes ) {
					Backbone.Relational.store.update( this );
				}

				if ( attributes ) {
					this.updateRelations( options );
				}
			}
			finally {
				&#x2F;&#x2F; Try to run the global queue holding external events
				Backbone.Relational.eventQueue.unblock();
			}
			
			return result;
		},

		unset: function( attribute, options ) {
			Backbone.Relational.eventQueue.block();
			
			var result = Backbone.Model.prototype.unset.apply( this, arguments );
			this.updateRelations( options );
			
			&#x2F;&#x2F; Try to run the global queue holding external events
			Backbone.Relational.eventQueue.unblock();
			
			return result;
		},

		clear: function( options ) {
			Backbone.Relational.eventQueue.block();
			
			var result = Backbone.Model.prototype.clear.apply( this, arguments );
			this.updateRelations( options );
			
			&#x2F;&#x2F; Try to run the global queue holding external events
			Backbone.Relational.eventQueue.unblock();
			
			return result;
		},

		clone: function() {
			var attributes = _.clone( this.attributes );
			if ( !_.isUndefined( attributes[ this.idAttribute ] ) ) {
				attributes[ this.idAttribute ] = null;
			}

			_.each( this.getRelations(), function( rel ) {
				delete attributes[ rel.key ];
			});

			return new this.constructor( attributes );
		},

		&#x2F;**
		 * Convert relations to JSON, omits them when required
		 *&#x2F;
		toJSON: function( options ) {
			&#x2F;&#x2F; If this Model has already been fully serialized in this branch once, return to avoid loops
			if ( this.isLocked() ) {
				return this.id;
			}
			
			this.acquire();
			var json = Backbone.Model.prototype.toJSON.call( this, options );
			
			if ( this.constructor._superModel &amp;&amp; !( this.constructor._subModelTypeAttribute in json ) ) {
				json[ this.constructor._subModelTypeAttribute ] = this.constructor._subModelTypeValue;
			}
			
			_.each( this._relations, function( rel ) {
				var value = json[ rel.key ];

				if ( rel.options.includeInJSON === true) {
					if ( value &amp;&amp; _.isFunction( value.toJSON ) ) {
						json[ rel.keyDestination ] = value.toJSON( options );
					}
					else {
						json[ rel.keyDestination ] = null;
					}
				}
				else if ( _.isString( rel.options.includeInJSON ) ) {
					if ( value instanceof Backbone.Collection ) {
						json[ rel.keyDestination ] = value.pluck( rel.options.includeInJSON );
					}
					else if ( value instanceof Backbone.Model ) {
						json[ rel.keyDestination ] = value.get( rel.options.includeInJSON );
					}
					else {
						json[ rel.keyDestination ] = null;
					}
				}
				else if ( _.isArray( rel.options.includeInJSON ) ) {
					if ( value instanceof Backbone.Collection ) {
						var valueSub = [];
						value.each( function( model ) {
							var curJson = {};
							_.each( rel.options.includeInJSON, function( key ) {
								curJson[ key ] = model.get( key );
							});
							valueSub.push( curJson );
						});
						json[ rel.keyDestination ] = valueSub;
					}
					else if ( value instanceof Backbone.Model ) {
						var valueSub = {};
						_.each( rel.options.includeInJSON, function( key ) {
							valueSub[ key ] = value.get( key );
						});
						json[ rel.keyDestination ] = valueSub;
					}
					else {
						json[ rel.keyDestination ] = null;
					}
				}
				else {
					delete json[ rel.key ];
				}

				if ( rel.keyDestination !== rel.key ) {
					delete json[ rel.key ];
				}
			});
			
			this.release();
			return json;
		}
	},
	{
		&#x2F;**
		 *
		 * @param superModel
		 * @returns {Backbone.RelationalModel.constructor}
		 *&#x2F;
		setup: function( superModel ) {
			&#x2F;&#x2F; We don&#x27;t want to share a relations array with a parent, as this will cause problems with
			&#x2F;&#x2F; reverse relations.
			this.prototype.relations = ( this.prototype.relations || [] ).slice( 0 );

			this._subModels = {};
			this._superModel = null;

			&#x2F;&#x2F; If this model has &#x27;subModelTypes&#x27; itself, remember them in the store
			if ( this.prototype.hasOwnProperty( &#x27;subModelTypes&#x27; ) ) {
				Backbone.Relational.store.addSubModels( this.prototype.subModelTypes, this );
			}
			&#x2F;&#x2F; The &#x27;subModelTypes&#x27; property should not be inherited, so reset it.
			else {
				this.prototype.subModelTypes = null;
			}

			&#x2F;&#x2F; Initialize all reverseRelations that belong to this new model.
			_.each( this.prototype.relations || [], function( rel ) {
				if ( !rel.model ) {
					rel.model = this;
				}
				
				if ( rel.reverseRelation &amp;&amp; rel.model === this ) {
					var preInitialize = true;
					if ( _.isString( rel.relatedModel ) ) {
						&#x2F;**
						 * The related model might not be defined for two reasons
						 *  1. it is related to itself
						 *  2. it never gets defined, e.g. a typo
						 *  3. the model hasn&#x27;t been defined yet, but will be later
						 * In neither of these cases do we need to pre-initialize reverse relations.
						 * However, for 3. (which is, to us, indistinguishable from 2.), we do need to attempt
						 * setting up this relation again later, in case the related model is defined later.
						 *&#x2F;
						var relatedModel = Backbone.Relational.store.getObjectByName( rel.relatedModel );
						preInitialize = relatedModel &amp;&amp; ( relatedModel.prototype instanceof Backbone.RelationalModel );
					}

					if ( preInitialize ) {
						Backbone.Relational.store.initializeRelation( null, rel );
					}
					else if ( _.isString( rel.relatedModel ) ) {
						Backbone.Relational.store.addOrphanRelation( rel );
					}
				}
			}, this );
			
			return this;
		},

		&#x2F;**
		 * Create a &#x27;Backbone.Model&#x27; instance based on &#x27;attributes&#x27;.
		 * @param {Object} attributes
		 * @param {Object} [options]
		 * @return {Backbone.Model}
		 *&#x2F;
		build: function( attributes, options ) {
			var model = this;

			&#x2F;&#x2F; &#x27;build&#x27; is a possible entrypoint; it&#x27;s possible no model hierarchy has been determined yet.
			this.initializeModelHierarchy();

			&#x2F;&#x2F; Determine what type of (sub)model should be built if applicable.
			&#x2F;&#x2F; Lookup the proper subModelType in &#x27;this._subModels&#x27;.
			if ( this._subModels &amp;&amp; this.prototype.subModelTypeAttribute in attributes ) {
				var subModelTypeAttribute = attributes[ this.prototype.subModelTypeAttribute ];
				var subModelType = this._subModels[ subModelTypeAttribute ];
				if ( subModelType ) {
					model = subModelType;
				}
			}
			
			return new model( attributes, options );
		},

		&#x2F;**
		 *
		 *&#x2F;
		initializeModelHierarchy: function() {
			&#x2F;&#x2F; If we&#x27;re here for the first time, try to determine if this modelType has a &#x27;superModel&#x27;.
			if ( _.isUndefined( this._superModel ) || _.isNull( this._superModel ) ) {
				Backbone.Relational.store.setupSuperModel( this );

				&#x2F;&#x2F; If a superModel has been found, copy relations from the _superModel if they haven&#x27;t been
				&#x2F;&#x2F; inherited automatically (due to a redefinition of &#x27;relations&#x27;).
				&#x2F;&#x2F; Otherwise, make sure we don&#x27;t get here again for this type by making &#x27;_superModel&#x27; false so we fail
				&#x2F;&#x2F; the isUndefined&#x2F;isNull check next time.
				if ( this._superModel ) {
					&#x2F;&#x2F;
					if ( this._superModel.prototype.relations ) {
						var supermodelRelationsExist = _.any( this.prototype.relations || [], function( rel ) {
							return rel.model &amp;&amp; rel.model !== this;
						}, this );

						if ( !supermodelRelationsExist ) {
							this.prototype.relations = this._superModel.prototype.relations.concat( this.prototype.relations );
						}
					}
				}
				else {
					this._superModel = false;
				}
			}

			&#x2F;&#x2F; If we came here through &#x27;build&#x27; for a model that has &#x27;subModelTypes&#x27;, and not all of them have been resolved yet, try to resolve each.
			if ( this.prototype.subModelTypes &amp;&amp; _.keys( this.prototype.subModelTypes ).length !== _.keys( this._subModels ).length ) {
				_.each( this.prototype.subModelTypes || [], function( subModelTypeName ) {
					var subModelType = Backbone.Relational.store.getObjectByName( subModelTypeName );
					subModelType &amp;&amp; subModelType.initializeModelHierarchy();
				});
			}
		},

		&#x2F;**
		 * Find an instance of &#x60;this&#x60; type in &#x27;Backbone.Relational.store&#x27;.
		 * - If &#x60;attributes&#x60; is a string or a number, &#x60;findOrCreate&#x60; will just query the &#x60;store&#x60; and return a model if found.
		 * - If &#x60;attributes&#x60; is an object and is found in the store, the model will be updated with &#x60;attributes&#x60; unless &#x60;options.update&#x60; is &#x60;false&#x60;.
		 *   Otherwise, a new model is created with &#x60;attributes&#x60; (unless &#x60;options.create&#x60; is explicitly set to &#x60;false&#x60;).
		 * @param {Object|String|Number} attributes Either a model&#x27;s id, or the attributes used to create or update a model.
		 * @param {Object} [options]
		 * @param {Boolean} [options.create=true]
		 * @param {Boolean} [options.merge=true]
		 * @param {Boolean} [options.parse=false]
		 * @return {Backbone.RelationalModel}
		 *&#x2F;
		findOrCreate: function( attributes, options ) {
			options || ( options = {} );
			var parsedAttributes = ( _.isObject( attributes ) &amp;&amp; options.parse &amp;&amp; this.prototype.parse ) ?
				this.prototype.parse( attributes ) : attributes;

			&#x2F;&#x2F; Try to find an instance of &#x27;this&#x27; model type in the store
			var model = Backbone.Relational.store.find( this, parsedAttributes );

			&#x2F;&#x2F; If we found an instance, update it with the data in &#x27;item&#x27; (unless &#x27;options.merge&#x27; is false).
			&#x2F;&#x2F; If not, create an instance (unless &#x27;options.create&#x27; is false).
			if ( _.isObject( attributes ) ) {
				if ( model &amp;&amp; options.merge !== false ) {
					model.set( parsedAttributes, options );
				}
				else if ( !model &amp;&amp; options.create !== false ) {
					model = this.build( attributes, options );
				}
			}

			return model;
		}
	});
	_.extend( Backbone.RelationalModel.prototype, Backbone.Semaphore );

	&#x2F;**
	 * Override Backbone.Collection._prepareModel, so objects will be built using the correct type
	 * if the collection.model has subModels.
	 * Attempts to find a model for &#x60;attrs&#x60; in Backbone.store through &#x60;findOrCreate&#x60;
	 * (which sets the new properties on it if found), or instantiates a new model.
	 *&#x2F;
	Backbone.Collection.prototype.__prepareModel = Backbone.Collection.prototype._prepareModel;
	Backbone.Collection.prototype._prepareModel = function ( attrs, options ) {
		var model;
		
		if ( attrs instanceof Backbone.Model ) {
			if ( !attrs.collection ) {
				attrs.collection = this;
			}
			model = attrs;
		}
		else {
			options || (options = {});
			options.collection = this;
			
			if ( typeof this.model.findOrCreate !== &#x27;undefined&#x27; ) {
				model = this.model.findOrCreate( attrs, options );
			}
			else {
				model = new this.model( attrs, options );
			}
			
			if ( model &amp;&amp; model.isNew() &amp;&amp; !model._validate( attrs, options ) ) {
				this.trigger( &#x27;invalid&#x27;, this, attrs, options );
				model = false;
			}
		}
		
		return model;
	};


	&#x2F;**
	 * Override Backbone.Collection.add, so we&#x27;ll create objects from attributes where required,
	 * and update the existing models. Also, trigger &#x27;relational:add&#x27;.
	 *&#x2F;
	var add = Backbone.Collection.prototype.__add = Backbone.Collection.prototype.add;
	Backbone.Collection.prototype.add = function( models, options ) {
		&#x2F;&#x2F; Short-circuit if this Collection doesn&#x27;t hold RelationalModels
		if ( !( this.model.prototype instanceof Backbone.RelationalModel ) ) {
			return add.apply( this, arguments );
		}

		models = _.isArray( models ) ? models.slice() : [ models ];
		&#x2F;&#x2F; Set default options to the same values as &#x60;add&#x60; uses, so &#x60;findOrCreate&#x60; will also respect those.
		options = _.extend( { merge: false }, options );

		var newModels = [],
			toAdd = [];

		&#x2F;&#x2F;console.debug( &#x27;calling add on coll=%o; model=%o, options=%o&#x27;, this, models, options );
		_.each( models, function( model ) {
			if ( !( model instanceof Backbone.Model ) ) {
				model = Backbone.Collection.prototype._prepareModel.call( this, model, options );
			}

			if ( model ) {
				toAdd.push( model );

				if ( !( this.get( model ) || this.get( model.cid ) ) ) {
					newModels.push( model );
				}
				&#x2F;&#x2F; If we arrive in &#x60;add&#x60; while performing a &#x60;set&#x60; (after a create, so the model gains an &#x60;id&#x60;),
				&#x2F;&#x2F; we may get here before &#x60;_onModelEvent&#x60; has had the chance to update &#x60;_byId&#x60;.
				else if ( model.id != null ) {
					this._byId[ model.id ] = model;
				}
			}
		}, this );

		&#x2F;&#x2F; Add &#x27;models&#x27; in a single batch, so the original add will only be called once (and thus &#x27;sort&#x27;, etc).
		add.call( this, toAdd, options );

		_.each( newModels, function( model ) {
			&#x2F;&#x2F; Fire a &#x60;relational:add&#x60; event for any model in &#x60;newModels&#x60; that has actually been added to the collection.
			if ( this.get( model ) || this.get( model.cid ) ) {
				this.trigger( &#x27;relational:add&#x27;, model, this, options );
			}
		}, this );
		
		return this;
	};

	&#x2F;**
	 * Override &#x27;Backbone.Collection.remove&#x27; to trigger &#x27;relational:remove&#x27;.
	 *&#x2F;
	var remove = Backbone.Collection.prototype.__remove = Backbone.Collection.prototype.remove;
	Backbone.Collection.prototype.remove = function( models, options ) {
		&#x2F;&#x2F; Short-circuit if this Collection doesn&#x27;t hold RelationalModels
		if ( !( this.model.prototype instanceof Backbone.RelationalModel ) ) {
			return remove.apply( this, arguments );
		}

		models = _.isArray( models ) ? models.slice() : [ models ];
		options || ( options = {} );

		var toRemove = [];

		&#x2F;&#x2F;console.debug(&#x27;calling remove on coll=%o; models=%o, options=%o&#x27;, this, models, options );
		_.each( models, function( model ) {
			model = this.get( model ) || this.get( model.cid );
			model &amp;&amp; toRemove.push( model );
		}, this );

		if ( toRemove.length ) {
			remove.call( this, toRemove, options );

			_.each( toRemove, function( model ) {
				this.trigger(&#x27;relational:remove&#x27;, model, this, options);
			}, this );
		}
		
		return this;
	};

	&#x2F;**
	 * Override &#x27;Backbone.Collection.reset&#x27; to trigger &#x27;relational:reset&#x27;.
	 *&#x2F;
	var reset = Backbone.Collection.prototype.__reset = Backbone.Collection.prototype.reset;
	Backbone.Collection.prototype.reset = function( models, options ) {
		reset.call( this, models, options );

		if ( this.model.prototype instanceof Backbone.RelationalModel ) {
			this.trigger( &#x27;relational:reset&#x27;, this, options );
		}

		return this;
	};

	&#x2F;**
	 * Override &#x27;Backbone.Collection.sort&#x27; to trigger &#x27;relational:reset&#x27;.
	 *&#x2F;
	var sort = Backbone.Collection.prototype.__sort = Backbone.Collection.prototype.sort;
	Backbone.Collection.prototype.sort = function( options ) {
		sort.call( this, options );

		if ( this.model.prototype instanceof Backbone.RelationalModel ) {
			this.trigger( &#x27;relational:reset&#x27;, this, options );
		}

		return this;
	};

	&#x2F;**
	 * Override &#x27;Backbone.Collection.trigger&#x27; so &#x27;add&#x27;, &#x27;remove&#x27; and &#x27;reset&#x27; events are queued until relations
	 * are ready.
	 *&#x2F;
	var trigger = Backbone.Collection.prototype.__trigger = Backbone.Collection.prototype.trigger;
	Backbone.Collection.prototype.trigger = function( eventName ) {
		&#x2F;&#x2F; Short-circuit if this Collection doesn&#x27;t hold RelationalModels
		if ( !( this.model.prototype instanceof Backbone.RelationalModel ) ) {
			return trigger.apply( this, arguments );
		}

		if ( eventName === &#x27;add&#x27; || eventName === &#x27;remove&#x27; || eventName === &#x27;reset&#x27; ) {
			var dit = this,
				args = arguments;
			
			if ( _.isObject( args[ 3 ] ) ) {
				args = _.toArray( args );
				&#x2F;&#x2F; the fourth argument is the option object.
				&#x2F;&#x2F; we need to clone it, as it could be modified while we wait on the eventQueue to be unblocked
				args[ 3 ] = _.clone( args[ 3 ] );
			}
			
			Backbone.Relational.eventQueue.add( function() {
				trigger.apply( dit, args );
			});
		}
		else {
			trigger.apply( this, arguments );
		}
		
		return this;
	};

	&#x2F;&#x2F; Override .extend() to automatically call .setup()
	Backbone.RelationalModel.extend = function( protoProps, classProps ) {
		var child = Backbone.Model.extend.apply( this, arguments );
		
		child.setup( this );

		return child;
	};
})();
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
